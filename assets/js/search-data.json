{"0": {
    "doc": "Download",
    "title": "Download",
    "content": " ",
    "url": "/download",
    "relUrl": "/download"
  },"1": {
    "doc": "Download",
    "title": "Table of contents",
    "content": ". | Prerequisite | Installation | . ",
    "url": "/download#table-of-contents",
    "relUrl": "/download#table-of-contents"
  },"2": {
    "doc": "Download",
    "title": "Prerequisite",
    "content": "MaudeSE supports various SMT solvers such as Z3, CVC4, CVC5, and Yices. MaudeSE provides connections to their Python bindings. Among these solvers, The Yices Python binding requires the Yices executable to be installed. Please follow the instructions of https://github.com/SRI-CSL/yices2 to install the Yices executable. ",
    "url": "/download#prerequisite",
    "relUrl": "/download#prerequisite"
  },"3": {
    "doc": "Download",
    "title": "Installation",
    "content": "Use pip to download the latest version of MaudeSE. $ pip install maude-se . As another option, we provide Python wheels for MaudeSE through our GitHub repository: https://github.com/postechsv/maude-se/releases. Download one of the wheels that matches your OS (either MacOS or Linux) and machine architecture (either arm64 or x86_64) and install using the following command: . $ pip install ./maude_se-&lt;MAUDE_SE_VERSION&gt;-cp&lt;YOUR_PYTHON_VERSION&gt;-cp&lt;YOUR_PYTHON_VERSION&gt;-&lt;YOUR_OS&gt;_&lt;YOUR_ARCH&gt;.whl . MaudeSE requires Python version 3.8 or newer. Use the following command to test successful installation. $ maude-se -h . If the installation was successful, you can see the following message. usage: maude-se [-h] [-s [SOLVER]] [-no-meta] [file] positional arguments: file input Maude file options: -h, --help show this help message and exit -s [SOLVER], -solver [SOLVER] set an underlying SMT solver * Supported solvers: {z3,yices,cvc5} * Usage: -s cvc5 * Default: -s z3 -no-meta no metaInterpreter . ",
    "url": "/download#installation",
    "relUrl": "/download#installation"
  },"4": {
    "doc": "Examples",
    "title": "Examples",
    "content": " ",
    "url": "/examples",
    "relUrl": "/examples"
  },"5": {
    "doc": "Examples",
    "title": "Table of contents",
    "content": ". | Examples for Metalevel Functions . | smt-check-ex.maude | smt-search-ex.maude | . | Module restrictions | . ",
    "url": "/examples#table-of-contents",
    "relUrl": "/examples#table-of-contents"
  },"6": {
    "doc": "Examples",
    "title": "Examples for Metalevel Functions",
    "content": "We provide a zip file (maude-se-examples.zip), containing example files. | File | Description | . | smt-check-ex.maude | A Maude file containing examples for metaSmtCheck function | . | smt-search-ex.maude | A Maude file containing examples for metaSmtSearch function | . smt-check-ex.maude . This file demonstrates the usage of metaSmtCheck using various theories and formulas including interpreted and uninterpreted symbols. The file contains four functional module: . | SIMPLE | EUF | EUF-ARRAY | EUF-XOR | . 1. SIMPLE Module: This module simply imports INTEGER module. fmod SIMPLE is pr INTEGER . pr META-SMT-CHECK . endfm . 2. EUF Module: This module defines a new sort A and an uninterpreted symbol f. fmod EUF is pr BOOLEAN . sort A . op _===_ : A A -&gt; Boolean . op f : A -&gt; A [ctor metadata \"smt euf\"] . endfm . 3. EUF-ARRAY Module: This module connects interpreted symbols from the Array theory to Maude operators. fmod ARRAY is pr REAL-INTEGER . sort Array{Integer,Integer} . op _===_ : Array{Integer,Integer} Array{Integer,Integer} -&gt; Boolean . op select : Array{Integer,Integer} Integer -&gt; Integer [metadata \"smt array:select\"] . op _[_] : Array{Integer,Integer} Integer -&gt; Integer [metadata \"smt array:select\"] . op store : Array{Integer,Integer} Integer Integer -&gt; Array{Integer,Integer} [metadata \"smt array:store\"] . endfm . 4. EUF-XOR Module: This module contains another example for uninterpreted symbol. fmod EUF-XOR is pr INTEGER . op _xor_ : Integer Integer -&gt; Integer [metadata \"smt euf\"] . endfm . As the modules EUF and EUF-XOR show, we can declare uninterpreted symbols by declaring operators and annotating them as uninterpreted symbols using the metadata attribute. For example, the uninterpreted symbol f of EUF is annotated with metadata smt euf, meaning that the operator is an SMT symbol (smt) and an uninterpreted symbol (euf). Another module ARRAY show how to connect interpreted symbol to Maude. We also use the metadata attribute. For example, we use the metadata smt array:select to denote the interpreted symbol select of the array theory. In addition, we can connect a single interpreted symbol to different Maude operators. For example, we connect the select to select and _[_] in the ARRAY module. To use metaSmtCheck, we need to import META-SMT-CHECK module. Then, we can check the satisfiability of various formulas under EUF and Array theories. For example, you can run the example with the CVC5 solver using the following command. $ maude-se ./smt-check-ex.maude -s cvc5 -no-meta . Hereâ€™s some results: . ========================================== reduce in SIMPLE : metaSmtCheck(upModule('INTEGER, false), upTerm(X:Integer &gt; (4).Integer), 'QF_LRA, true) . result SmtCheckResult: {'X:Integer |-&gt; '5.Integer} ========================================== reduce in EUF-XOR-CHECK : metaSmtCheck(upModule('EUF-XOR, false), upTerm((0).Integer &lt;= (N xor (255).Integer)), 'QF_UFLIA, true) . result SmtCheckResult: {('N:Integer |-&gt; '1.Integer),{\"_xor_\" |-&gt; \"(lambda ((_arg_1 Int) (_arg_2 Int)) 0)\"}} ========================================== ... smt-search-ex.maude . This file provides examples for metaSmtSearch using gcd and robot examples. mod GCD is pr INTEGER . sorts GcdResult . op gcd : Integer Integer -&gt; GcdResult [ctor] . op return : Integer -&gt; GcdResult [ctor] . vars X Y : Integer . crl [r1] : gcd(X, Y) =&gt; gcd(X - Y, Y) if X &gt; Y = true [nonexec] . crl [r2] : gcd(X, Y) =&gt; gcd(X, Y - X) if X &lt; Y = true [nonexec] . crl [r3] : gcd(X, Y) =&gt; return (X) if X === Y = true [nonexec] . endm . omod ROBOT is pr REAL . class Robot | pos : Vector, vel : Vector, acc : Vector, time : Real . sort Vector . op [_,_] : Real Real -&gt; Vector [ctor] . endom omod ROBOT-DYNAMICS is pr ROBOT . vars O : Oid . vars CONST CONST' : Boolean . vars PX VX AX PY VY AY PX' VX' AX' PY' VY' AY' T T' TAU : Real . crl [move]: &lt; O : Robot | pos : [PX, PY], vel : [VX, VY], acc : [AX, AY], time : T &gt; =&gt; &lt; O : Robot | pos : [PX', PY'], vel : [VX', VY'], time : T + TAU &gt; if TAU &gt;= 0/1 and VX' === VX + AX * TAU and VY' === VY + AY * TAU and PX' === 1/2 * AX * TAU * TAU + VX * TAU + PX and PY' === 1/2 * AY * TAU * TAU + VY * TAU + PY = true [nonexec] . crl [accX]: &lt; O : Robot | acc : [AX, AY] &gt; =&gt; &lt; O : Robot | acc : [AX', AY] &gt; if AY === 0/1 = true [nonexec] . crl [accY]: &lt; O : Robot | acc : [AX, AY] &gt; =&gt; &lt; O : Robot | acc : [AX, AY'] &gt; if AX === 0/1 = true [nonexec] . op r : -&gt; Oid [ctor] . endom . To use metaSmtSearch, we need to import META-SMT-SEARCH module. The following commands show how to perform rewriting modulo SMT. --- gcd(10, I) =&gt;* return(J) such that I &lt; 9 and I &gt; 0 = true . red metaSmtSearch(upModule('GCD, false), upTerm(gcd(10, I)), upTerm(return(J)), upTerm(I &lt; 9 and I &gt; 0) = upTerm((true).Boolean), '*, unbounded, 0, 'QF_LRA) . red metaSmtSearch(upModule('ROBOT-DYNAMICS, false), upTerm(&lt; r : Robot | pos : [IPX, IPY], vel : [IVX, IVY], acc : [IAX, IAY], time : CLK &gt;), upTerm(&lt; r : Robot | pos : [NPX, NPY], ATTRSET &gt;), upTerm(NPX === 10/1 and NPY === 10/1 and IPX === 0/1 and IPY === 0/1 and IVX === 0/1 and IVY === 0/1 and IAX === 0/1 and IAY === 0/1 and CLK === 0/1) = upTerm((true).Boolean), '*, unbounded, 0, 'QF_NRA) . The first command searches for the first solution term that matches return(J) and satisfies the consition I &lt; 9 and I &gt; 0, starting from an initial term gcd(10, I) without folding under the QF_LRA logic. The second command searches for the first solution, with the QF_NRA logic, that matches the goal pattern &lt; r : Robot | pos : [NPX, NPY], ATTRSET &gt; and satisfies the consition NPX === 10/1 and NPY === 10/1, starting from an initial term, where all its attributes are zeros. We can run the both commands with Z3 using the following command: . $ maude-se smt-search-ex.maude -no-meta . The search results are as follows. ========================================== reduce in GCD-ANALYSIS : metaSmtSearch(upModule('GCD, false), upTerm(gcd((10).Integer, I)), upTerm(return(J)), upTerm(I &lt; (9).Integer and I &gt; (0).Integer) = upTerm((true).Boolean), '*, unbounded, (0).Zero, 'QF_LRA) . rewrites: 310 in 5ms cpu (9ms real) (52837 rewrites/second) result SmtResult2: {'return['%%ubVar$5:Integer],..., ... '%%ubVar$1:Integer &lt;- '5.Integer ; '%%ubVar$2:Integer &lt;- '5.Integer ; '%%ubVar$3:Integer &lt;- '10.Integer ; '%%ubVar$4:Integer &lt;- '5.Integer ; '%%ubVar$5:Integer &lt;- '5.Integer ; '%%ubVar$6:Integer &lt;- '5.Integer ; 'I:Integer &lt;- '5.Integer ; 'J:Integer &lt;- '5.Integer ; 'V0:Integer &lt;- '10.Integer ; 'V1:Integer &lt;- '5.Integer ; 'V2:Integer &lt;- '5.Integer, (6).NzNat, (3).NzNat} ========================================== reduce in ROBOT-ANALYSIS : metaSmtSearch(upModule('ROBOT-DYNAMICS, false), upTerm(&lt; r : Robot | pos : [IPX, IPY], vel : [IVX, IVY], acc : [IAX, IAY], time : CLK &gt;), upTerm(&lt; r : Robot | ATTRSET, pos : [NPX, NPY] &gt;), upTerm(NPX === (10/1).Real and NPY === (10/1).Real and IPX === (0/1).Real and IPY === (0/1).Real and IVX === (0/1).Real and IVY === (0/1).Real and IAX === (0/1).Real and IAY === (0/1).Real and CLK === (0/1).Real) = upTerm((true).Boolean), '*, unbounded, (0).Zero, 'QF_NRA) . rewrites: 1181 in 386ms cpu (391ms real) (3055 rewrites/second) result SmtResult2: {'&lt;_:_|_&gt;['r.Oid, 'Robot.Robot ..... '%%ubVar$9:Real &lt;- '20/3.Real ; 'CLK:Real &lt;- '0/1.Real ; 'IAX:Real &lt;- '0/1.Real ; 'IAY:Real &lt;- '0/1.Real ; 'IPX:Real &lt;- '0/1.Real ; 'IPY:Real &lt;- '0/1.Real ; 'IVX:Real &lt;- '0/1.Real ; 'IVY:Real &lt;- '0/1.Real ; 'NPX:Real &lt;- '10/1.Real ; 'NPY:Real &lt;- '10/1.Real ; 'V0:Real &lt;- '0/1.Real ; 'V1:Real &lt;- '0/1.Real ; 'V2:Real &lt;- '0/1.Real ; 'V3:Real &lt;- '0/1.Real ; 'V4:Real &lt;- '0/1.Real ; 'V5:Real &lt;- '0/1.Real ; 'V6:Real &lt;- '0/1.Real ; 'V7:Real &lt;- '10/1.Real ; 'V8:Real &lt;- '10/1.Real, (53).NzNat, (180).NzNat} . As we need to explore 180 states to find reachable state for robot example, we can reduce the search space by enabling folding as follows. reduce in ROBOT-ANALYSIS : metaSmtSearch(upModule('ROBOT-DYNAMICS, false), upTerm(&lt; r : Robot | pos : [IPX, IPY], vel : [IVX, IVY], acc : [IAX, IAY], time : CLK &gt;), upTerm(&lt; r : Robot | ATTRSET, pos : [NPX, NPY] &gt;), upTerm(NPX === (10/1).Real and NPY === (10/1).Real and IPX === (0/1).Real and IPY === (0/1).Real and IVX === (0/1).Real and IVY === (0/1).Real and IAX === (0/1).Real and IAY === (0/1).Real and CLK === (0/1).Real) = upTerm((true).Boolean), '*, unbounded, 0, 'QF_NRA, true) . rewrites: 1145 in 11073ms cpu (11138ms real) (103 rewrites/second) result SmtResult2: {'&lt;_:_|_&gt;[...] ; ... '%%ubVar$11:Real &lt;- '20/3.Real ; '%%ubVar$7:Real &lt;- '10/3.Real ; '%%ubVar$8:Real &lt;- '0/1.Real ; '%%ubVar$9:Real &lt;- '20/3.Real ; 'CLK:Real &lt;- '0/1.Real ; 'IAX:Real &lt;- '0/1.Real ; 'IAY:Real &lt;- '0/1.Real ; 'IPX:Real &lt;- '0/1.Real ; 'IPY:Real &lt;- '0/1.Real ; ... 'V8:Real &lt;- '10/1.Real, (53).NzNat, (128).NzNat} . The result shows that we could find the same solution by exploring 128 states. ",
    "url": "/examples#examples-for-metalevel-functions",
    "relUrl": "/examples#examples-for-metalevel-functions"
  },"7": {
    "doc": "Examples",
    "title": "Module restrictions",
    "content": "Currently, we make several restrictions to rewrite rules and equations: . | Rewrite rules should not have non-SMT constraints in their conditions. | Equations should not contradict or conflict with SMT theories. | When defining and connecting SMT symbols using metadata, one should not use equational axiom attritues (e.g., assoc, comm, id) and the metadata attributes together. | . ",
    "url": "/examples#module-restrictions",
    "relUrl": "/examples#module-restrictions"
  },"8": {
    "doc": "Home",
    "title": "About Maude SE",
    "content": "Maude-SE is a rewriting modulo SMT extension of Maude, which is a flexible yet efficient framework for connecting SMT solvers to Maude. It supports symbolic reachability analysis with folding, an SMT check with various SMT theories, and an abstract connector at the Python level that makes it easy to integrate and customize SMT solving, without having to understand Maudeâ€™s internal implementation. Get started now . ",
    "url": "/#about-maude-se",
    "relUrl": "/#about-maude-se"
  },"9": {
    "doc": "Home",
    "title": "Bug report",
    "content": "To report bugs (or provide any suggestions), please contact maude-se@postech.ac.kr. ",
    "url": "/#bug-report",
    "relUrl": "/#bug-report"
  },"10": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    "relUrl": "/"
  },"11": {
    "doc": "Previous Version",
    "title": "Previous Version of Maude-SE",
    "content": " ",
    "url": "/old#previous-version-of-maude-se",
    "relUrl": "/old#previous-version-of-maude-se"
  },"12": {
    "doc": "Previous Version",
    "title": "Table of contents",
    "content": ". | About Maude SE | Getting started | How to Cite | Download . | Supported Version | . | SMT Interface . | Full Maude Interface . | Search Command | Usage | . | Core Maude Interface . | Core Maude Functions | Usage | . | . | Examples . | Full Maude Robot | GCD | Robot | . | . ",
    "url": "/old#table-of-contents",
    "relUrl": "/old#table-of-contents"
  },"13": {
    "doc": "Previous Version",
    "title": "About Maude SE",
    "content": "Maude SE is a rewriting modulo SMT extension of Maude at C++ level. It provides a Maude user interface to specify an SMT formula with equations and rules and can generate a set of concrete assignments when the formula is satisfied. Currently supported SMT solvers are Z3, Yices2, CVC4, and dReal. Get started now Paper . Maude-SE is an SMT extension of Maude that tightly integrates Maude and SMT solvers with extra functionality. It extends the original Maude-SMT at core Maude level. In addition to the existing SMT solving capability of Maude, the tool provides three additional features that are not currently supported by Maude but that are very useful for rewriting modulo SMT: . | building satisfying assignments by SMT solving, | simplifying formulas using the underlying SMT solver, and | dealing with non-linear arithmetic formulas. | . Maude-SE can analyze nontrivial systems that cannot be dealt with by the previous Maude-SMT implementation. There are three versions of Maude SE (i.e., Z3, Yices2, CVC4), depending on an underlying SMT solver it uses. ",
    "url": "/old#about-maude-se",
    "relUrl": "/old#about-maude-se"
  },"14": {
    "doc": "Previous Version",
    "title": "Getting started",
    "content": "To use Maude SE, please follow the instructions below: . | Download one of the zip files from here (e.g., maude-se-z3.tar.gz). | Extract the zip file to somewhere you want. # you can see `smt-check.maude` at the top directory. $ tar -xvzf maude-se-z3.tar.gz &amp;&amp; cd maude-se-z3 . | Load or include smt-check.maude in your own module. | . ",
    "url": "/old#getting-started",
    "relUrl": "/old#getting-started"
  },"15": {
    "doc": "Previous Version",
    "title": "How to Cite",
    "content": "To cite our paper, use the following bibtex format or refer to the google scholar. @article{yu2020maude, title={Maude-SE: A tight integration of Maude and SMT solvers}, author={Yu, Geunyeol and Bae, Kyungmin}, journal={Rewriting Logic and its Applications}, pages={220}, year={2020} } . ",
    "url": "/old#how-to-cite",
    "relUrl": "/old#how-to-cite"
  },"16": {
    "doc": "Previous Version",
    "title": "Download",
    "content": "Maude-SE currently supports three major SMT solvers: Z3, Yices2 (a variation of Yices solver Yices2-mcsat), and CVC4. Maude-SE with Z3, Yices2-mcsat, and CVC4 support quantifier free nonlinear theories as well as linear theories, while Yices only supports linear ones. We will going to support dReal SMT solver (dReal3 and dReal4) in the future. Supported Version . | # | Name | Files | . | 1 | maude-se-z3 | [MacOS][Ubuntu] | . | 2 | maude-se-yices2 | [MacOS][Ubuntu] | . | 3 | maude-se-yices2-mcsat | [MacOS][Ubuntu] | . | 4 | maude-se-cvc4 | [MacOS][Ubuntu] | . | 5 | maude-se-dreal4 | Â  | . Currently, we support Maude-SE executables for Linux 64 bits only. We will provide executables for MacOS later. ",
    "url": "/old#download",
    "relUrl": "/old#download"
  },"17": {
    "doc": "Previous Version",
    "title": "SMT Interface",
    "content": "Full Maude Interface . The Full Maude interface of Maude SE provides smt-search2 command for symbolic reachability analysis. Search Command . Given an initial state t, a goal pattern u, and a goal condition cond, the following command searches for n states that are reachable within m rewrite steps from the initial state t, match the goal pattern u, and satisfy the goal condition cond. (smt-search2 [n, m] in M : t =&gt;* u such that cond.) . Usage . To see the usage of this command, refer to the Maude-SE paper for more details. For the simple usage of the command, see the full/robot.maude example. Core Maude Interface . The main functionality of the Maude SE is implemented in the predefined functional module SMT-CHECK which also contains signatures for both SMT formulas and their solutions. The interface contains two main functions in the module SMT-CHECK: . | smtCheck for checking the satisfiability of an SMT formula, and | simplifyFormula for simplifying the formula. | . Core Maude Functions . op smtCheck : BooleanExpr -&gt; SmtCheckResult . eq smtCheck(BE:BooleanExpr) = smtCheck(BE:BooleanExpr, false) . op smtCheck : BooleanExpr Bool -&gt; SmtCheckResult [special ... )] . op simplifyFormula : BooleanExpr -&gt; BooleanExpr [special ... )] . op simplifyFormula : IntegerExpr -&gt; IntegerExpr [special ... )] . op simplifyFormula : RealExpr -&gt; RealExpr [special ... )] . Usage . To see the usages of these functions, see gcd.maude and robot.maude examples. ",
    "url": "/old#smt-interface",
    "relUrl": "/old#smt-interface"
  },"18": {
    "doc": "Previous Version",
    "title": "Examples",
    "content": "We provide three examples: robot-full.maude, gcd.maude, and robot.maude. Full Maude Robot . (omod ROBOT-DYNAMICS is pr REAL . inc CONFIGURATION . sort Vector . op `[_`,_`] : Real Real -&gt; Vector [ctor] . sorts RobotTraceItem RobotTrace . subsort Vector &lt; RobotTraceItem &lt; RobotTrace . op ==`(_:_`)==&gt; : Vector Real -&gt; RobotTraceItem [ctor] . op __ : RobotTrace RobotTrace -&gt; RobotTrace [ctor assoc] . class Robot | pos : Vector, vel : Vector, acc : Vector, clock : Real, trace : RobotTrace . sort State . op r : -&gt; Oid [ctor] . subsort Configuration &lt; State . vars O : Oid . vars PX VX AX PY VY AY PX' VX' AX' PY' VY' AY' T T' TAU : Real . var ATTS : AttributeSet . var TRACE : RobotTrace . crl [move]: &lt; O : Robot | pos : [PX, PY], vel : [VX, VY], acc : [AX, AY], clock : T, trace : TRACE &gt; =&gt; &lt; O : Robot | pos : [PX', PY'], vel : [VX', VY'], clock : T + TAU, trace : TRACE ==([VX', VY'] : T + TAU)==&gt; [PX', PY'] &gt; if VX' = VX + AX * TAU /\\ VY' = VY + AY * TAU /\\ PX' = 1/2 * AX * TAU * TAU + VX * TAU + PX /\\ PY' = 1/2 * AY * TAU * TAU + VY * TAU + PY /\\ TAU &gt;= 0/1 = true [nonexec] . crl [accX]: &lt; O : Robot | acc : [AX, AY] &gt; =&gt; &lt; O : Robot | acc : [AX', AY] &gt; if AY = 0/1 [nonexec] . crl [accY]: &lt; O : Robot | acc : [AX, AY] &gt; =&gt; &lt; O : Robot | acc : [AX, AY'] &gt; if AX = 0/1 [nonexec] . endom) (smt-search2 [1] &lt; r : Robot | pos : [0/1, 0/1], vel : [0/1, 0/1], acc : [0/1, 0/1], clock : 0/1, trace : [0/1, 0/1] &gt; =&gt;* &lt; r : Robot | pos : [10/1, 10/1] &gt; .) . To run the full-maude robot example using Z3 binding of Maude SE, go to the top directory (where the exectuable is placed) and type the following command: . $ ./maude-se-z3 examples/full/robot.maude . GCD . mod GCD is protecting INTEGER-EXPR . pr SMT-CHECK . pr META-LEVEL . ops a b : -&gt; SMTVarId [ctor] . sort GcdResult . op gcd : IntegerExpr IntegerExpr -&gt; GcdResult [ctor] . op ret : IntegerExpr -&gt; GcdResult [ctor] . sort State . op {_,_} : BooleanExpr GcdResult -&gt; State [ctor] . vars CONST CONST' : BooleanExpr . vars X Y : IntegerExpr . var SS : SatAssignmentSet . crl {CONST, gcd(X, Y)} =&gt; {simplifyFormula(CONST'), gcd(X - Y, Y)} if CONST' := CONST and (X &gt; Y) === (true).Boolean / smtCheck(CONST', false) . crl {CONST, gcd(X, Y)} =&gt; {simplifyFormula(CONST'), gcd(X, Y - X)} if CONST' := CONST and (X &lt; Y) === (true).Boolean / smtCheck(CONST', false) . crl {CONST, gcd(X, Y)} =&gt; {simplifyFormula(CONST'), ret(X)} if CONST' := CONST and (X === Y) === (true).Boolean / smtCheck(CONST', false) . endm search [1] {true, gcd(i(a), i(b))} =&gt;* {CONST, ret(NN:IntegerExpr)} such that CONST' := CONST and i(a) + i(b) === 27 and NN:IntegerExpr === 3 /\\ smtCheck(CONST') = (true).Bool . To run the GCD example using Z3 binding of Maude SE, go to top directory (whre the executable is placed) and type the following command: . $ ./maude-se-z3 examples/gcd.maude . Robot . mod ROBOT is pr REAL-EXPR . inc CONFIGURATION . sort Robot . subsort Robot &lt; Cid . op Robot : -&gt; Robot [ctor format(! o)] . op pos`:_ : Vector -&gt; Attribute [ctor gather(&amp;)] . op vel`:_ : Vector -&gt; Attribute [ctor gather(&amp;)] . op acc`:_ : Vector -&gt; Attribute [ctor gather(&amp;)] . op time`:_ : RealExpr -&gt; Attribute [ctor gather(&amp;)] . sort Vector . op [_,_] : RealExpr RealExpr -&gt; Vector [ctor] . endm mod ROBOT-DYNAMICS is pr ROBOT . pr SMT-CHECK . inc NAT . pr META-LEVEL . sort State . subsort Nat &lt; SMTVarId . op {_,_,_} : BooleanExpr Nat Configuration -&gt; State [ctor] . var N : Nat . vars O : Oid . vars CONST CONST' : BooleanExpr . vars PX VX AX PY VY AY PX' VX' AX' PY' VY' AY' T T' TAU : RealExpr . var ATTS : AttributeSet . crl [move]: {CONST, N, &lt; O : C:Robot | pos : [PX, PY], vel : [VX, VY], acc : [AX, AY], time : T, ATTS &gt;} =&gt; {CONST', N + 5, &lt; O : C:Robot | pos : [PX', PY'], vel : [VX', VY'], acc : [AX, AY], time : T + TAU, ATTS &gt;} if TAU := r(N) /\\ [PX', PY'] := [r(N + 1), r(N + 2)] /\\ [VX', VY'] := [r(N + 3), r(N + 4)] /\\ CONST' := simplifyFormula(CONST and TAU &gt;= toReal(0) and VX' === VX + AX * TAU and VY' === VY + AY * TAU and PX' === 1/2 * AX * TAU * TAU + VX * TAU + PX and PY' === 1/2 * AY * TAU * TAU + VY * TAU + PY) /\\ smtCheck(CONST') . crl [accX]: {CONST, N, &lt; O : C:Robot | acc : [AX, AY], ATTS &gt;} =&gt; {CONST', s N, &lt; O : C:Robot | acc : [AX', AY], ATTS &gt;} if AX' := r(N) /\\ CONST' := simplifyFormula(CONST and AY === toReal(0)) /\\ smtCheck(CONST') . crl [accY]: {CONST, N, &lt; O : C:Robot | acc : [AX, AY], ATTS &gt;} =&gt; {CONST', s N, &lt; O : C:Robot | acc : [AX, AY'], ATTS &gt;} if AY' := r(N) /\\ CONST' := simplifyFormula(CONST and AX === toReal(0)) /\\ smtCheck(CONST') . endm mod ROBOT-ANALYSIS is inc ROBOT-DYNAMICS . var N : Nat . vars CONST : BooleanExpr . vars PX VX AX PY VY AY T : RealExpr . var SS : SatAssignmentSet . var OBJ : Object . var ATTS : AttributeSet . op r : -&gt; Oid [ctor] . endm search [1] {true, 0, &lt; r : Robot | pos : [toReal(0), toReal(0)], vel : [toReal(0), toReal(0)], acc : [toReal(0), toReal(0)], time : toReal(0) &gt;} =&gt;* {CONST, N, &lt; r : Robot | pos : [PX, PY], ATTS &gt;} such that {SS} := smtCheck(CONST and PX === 10/1 and PY === 10/1, true) . To run the robot example using Z3 binding of Maude SE, go to top directory (whre the executable is placed) and type the following command: . $ ./maude-se-z3 examples/robot.maude . ",
    "url": "/old#examples",
    "relUrl": "/old#examples"
  },"19": {
    "doc": "Previous Version",
    "title": "Previous Version",
    "content": " ",
    "url": "/old",
    "relUrl": "/old"
  },"20": {
    "doc": "SMT Interface",
    "title": "SMT Interface",
    "content": " ",
    "url": "/smt-interface",
    "relUrl": "/smt-interface"
  },"21": {
    "doc": "SMT Interface",
    "title": "Table of contents",
    "content": ". | Analysis Commands . | check | show model | smt-search | show smt-path | . | Metalevel Functions . | metaSmtCheck | metaSmtSearch | metaSmtSearchPath | . | . ",
    "url": "/smt-interface#table-of-contents",
    "relUrl": "/smt-interface#table-of-contents"
  },"22": {
    "doc": "SMT Interface",
    "title": "Analysis Commands",
    "content": "MaudeSE provides various analysis commands: . | check | show model | smt-search | show smt-path | . check . The check command determines the satisfiability of boolean formulas. For a given module M, a boolean formula f, and an (optional) SMT theory Th, it determines the satisfiability of f under the theory Th. check in M : f using Th . For example, consider a module EUF-EX. fmod EUF-EX is protecting INTEGER . sort A . op f : A -&gt; A [metadata \"smt euf\"] . op _xor_ : Integer Integer -&gt; A [prec 30 \"smt euf\"] . op _===_ : A A -&gt; Boolean . endfm . We can check the satisfiability using the command as follows: . MaudeSE&gt; check in EUF-EX : I:Integer &gt; 2 and I:Integer xor J:Integer &gt; 3 and f(X:A) === X:A using QF_UF . result: sat . show model . The show model command returns the satisfying assignment, if any, for the last check command. For example, we can get the assigment of the above check example as follows: . MaudeSE&gt; show model . assignment: I |--&gt; 3; J |--&gt; 2; X |--&gt; A!val!0; _xor_ |--&gt; [else-&gt; 4]; f |--&gt; [else-&gt; A!val!0] . smt-search . This command performs symbolic reachability analysis, along with folding. Given an initial term t, a goal pattern u, and a goal condition c, the following command searches for n solutions that are reachable within m rewrite steps from t, match the goal pattern u, and satisfy the goal condition c under the SMT theory Th: . {fold} smt-search [n,m] in M : t =&gt;* u such that c using Th . The arguments {fold}, Th, n, and m are optional. If {fold} is given, the command ignores constrained terms that are subsumed by other constrained terms. As an example, consider the following system module COFFEE-MACHINE that specifies the coffee machine parametric timed automaton (PTA). mod COFFEE-MACHINE is protecting REAL . sorts State Location . vars T X Y X' Y' P1 P2 P3 : Real . vars L L' : Location . var PHI : Boolean . ops idle addsugar preparingcoffee cdone : -&gt; Location . op &lt;_;_;_&gt; &lt;_;_;_&gt; : Location Real Real Real Real Real -&gt; State . op [_;_;_] &lt;_;_;_&gt; : Location Real Real Real Real Real -&gt; State . sort Tuple{Location,Real,Real,Boolean} . op {_,_,_,_} : Location Real Real Boolean -&gt; Tuple{Location,Real,Real,Boolean} [ctor] . crl [tick] : [ L ; X ; Y ] &lt; P1 ; P2 ; P3 &gt; =&gt; &lt; L ; X + T ; Y + T &gt; &lt; P1 ; P2 ; P3 &gt; if PHI := tickCond(L, T, X, Y, P2, P3) /\\ (T &gt;= 0/1 and PHI) = true [nonexec] . op tickCond : Location Real Real Real Real Real -&gt; Boolean . eq tickCond(idle, T, X, Y, P2, P3) = true . eq tickCond(addsugar, T, X, Y, P2, P3) = Y + T &lt;= P2 . eq tickCond(preparingcoffee, T, X, Y, P2, P3) = Y + T &lt;= P3 . eq tickCond(cdone, T, X, Y, P2, P3) = X + T &lt;= 10/1 . crl [toAddsugar] : &lt; L ; X ; Y &gt; &lt; P1 ; P2 ; P3 &gt; =&gt; [ L' ; X' ; Y' ] &lt; P1 ; P2 ; P3 &gt; if {L', X', Y', PHI} := nextAddSugar(L, X, Y, P1, P2) /\\ PHI = true . op nextAddSugar : Location Real Real Real Real -&gt; Tuple{Location,Real,Real,Boolean} . eq nextAddSugar(idle, X, Y, P1, P2) = {addsugar, 0/1, 0/1, 0/1 &lt;= P2} . eq nextAddSugar(addsugar, X, Y, P1, P2) = {addsugar, 0/1, Y, Y &lt;= P2 and X &gt;= P1} . eq nextAddSugar(cdone, X, Y, P1, P2) = {addsugar, 0/1, 0/1, 0/1 &lt;= P2} . crl [toOther] : &lt; L ; X ; Y &gt; &lt; P1 ; P2 ; P3 &gt; =&gt; [ L' ; X' ; Y' ] &lt; P1 ; P2 ; P3 &gt; if {L', X', Y', PHI} := nextOther(L, X, Y, P2, P3) /\\ PHI = true . op nextOther : Location Real Real Real Real -&gt; Tuple{Location,Real,Real,Boolean} . eq nextOther(addsugar, X, Y, P2, P3) = {preparingcoffee, X, Y, Y &lt;= P3 and Y === P2} . eq nextOther(preparingcoffee, X, Y, P2, P3) = {cdone, 0/1, Y, 0/1 &lt;= 10/1 and Y === P3} . eq nextOther(cdone, X, Y, P2, P3) = {idle, X, Y, X === 10/1} . endm . The following command finds the first solution of the PTA coffee machine that goes to cdone with all the clocks and parameters are greater than or equal to 0. MaudeSE&gt; {fold} smt-search [1] in COFFEE-MACHINE : &lt; idle ; X:Real ; Y:Real &gt; &lt; P1:Real ; P2:Real ; P3:Real &gt; =&gt;* &lt; cdone ; Xâ€™:Real ; Yâ€™:Real &gt; &lt; P1:Real ; P2:Real ; P3:Real &gt; such that X:Real === Y:Real and X:Real &gt;= 0/1 and Y:Real &gt;= 0/1 and P1:Real &gt;= 0/1 and P2:Real &gt;= 0/1 and P3:Real &gt;= 0/1 using QF_LRA . Solution 1 (state 12) Symbolic state: &lt; cdone ; %%ubVar$58:Real ; %%ubVar$59:Real &gt; &lt; %%ubVar$60:Real ; %%ubVar$61:Real ; %%ubVar$62:Real &gt; Constraint: V0:Real === X:Real and V1:Real === Y:Real and V2:Real === P1:Real ... Substitution: V5:Real &lt;-- %%ubVar$58:Real V6:Real &lt;-- %%ubVar$59:Real V7:Real &lt;-- %%ubVar$60:Real V8:Real &lt;-- %%ubVar$61:Real V9:Real &lt;-- %%ubVar$62:Real Assignment: %%ubVar$10:Real &lt;-- 0/1 %%ubVar$11:Real &lt;-- 0/1 %%ubVar$12:Real &lt;-- 0/1 %%ubVar$13:Real &lt;-- 0/1 %%ubVar$14:Real &lt;-- 0/1 %%ubVar$15:Real &lt;-- 0/1 ... Concrete state: &lt; cdone ; 0/1 ; 0/1 &gt; &lt; 0/1 ; 0/1 ; 0/1 &gt; . show smt-path . This command returns a symbolic/concrete path of the last smt-search result. It takes a path type (either symbolic or concrete). A symbolic path is given by a sequence of contracted terms and rewrite rules. The corresponding concrete path is an instance of the symbolic path with a satisfying assignment. For example, the following commands show the symbolic and concrete paths of the above smt-search command. MaudeSE&gt; show smt-path symbolic . Constrained Term: Term: &lt; idle ; V0:Real ; V1:Real &gt; &lt; V2:Real ; V3:Real ; V4:Real &gt; Constraint: V0:Real === X:Real and V1:Real === Y:Real and ... =====[toAddsugar]=====&gt; Constrained Term: Term: [addsugar ; %%ubVar$5:Real ; %%ubVar$6:Real]&lt; %%ubVar$7:Real ; %%ubVar$8:Real ; %%ubVar$9:Real &gt; Constraint: V0:Real === X:Real and V1:Real === Y:Real and ..... MaudeSE&gt; show smt-path concrete . &lt; idle ; 0/1 ; 0/1 &gt; &lt; 0/1 ; 0/1 ; 0/1 &gt; =====[toAddsugar]=====&gt; [addsugar ; 0/1 ; 0/1]&lt; 0/1 ; 0/1 ; 0/1 &gt; ... ",
    "url": "/smt-interface#analysis-commands",
    "relUrl": "/smt-interface#analysis-commands"
  },"23": {
    "doc": "SMT Interface",
    "title": "Metalevel Functions",
    "content": "MaudeSE provides three meta-level functions: . | metaSmtCheck | metaSmtSearch | metaSmtSearchPath | . metaSmtCheck . This function checks the satisfiability of SMT queries, as similar to metaCheck, but it can handle various theories (with uninterpreted functions) and generate satisfying assignments. The usage of metaSmtCheck is similar to metaCheck except that it takes an SMT logic and a boolean flag as its arguments, where the flag decides whether to generate a satisfying assignment for the satisfiable case. op metaSmtCheck : Module Term Qid -&gt; SmtCheckResult . eq metaSmtCheck(M:Module, TERM:Term, LOGIC:Qid) = metaSmtCheck(M:Module, TERM:Term, LOGIC:Qid, false) . op metaSmtCheck : Module Term Qid Bool -&gt; SmtCheckResult [special (id-hook MetaLevelSmtOpSymbol (metaSmtCheck) op-hook unknownResultSymbol (unknown : ~&gt; SmtCheckResult) ...)] . The check result is given as a term of sort SmtCheckResult, which can be one of unknown, true, false, or {_}. The symbol {_} consists of a set of assignments, where each assignment is denoted as a term _|-&gt;_. sort SmtCheckResult . subsort Bool &lt; SmtCheckResult . op unknown : -&gt; SmtCheckResult [ctor] . op {_} : SatAssignmentSet -&gt; SmtCheckResult [ctor] . sort SatAssignment . op _|-&gt;_ : Term Term -&gt; SatAssignment [ctor] . sort SatAssignmentSet . subsort SatAssignment &lt; SatAssignmentSet . op empty : -&gt; SatAssignmentSet [ctor] . op _,_ : SatAssignmentSet SatAssignmentSet -&gt; SatAssignmentSet [ctor comm assoc id: empty] . metaSmtSearch . This function performs search using rewriting modulo SMT, similar to metaSmtSearch, but supports folding. The usage of metaSmtSearch is similar to metaSmtSearch except that it takes a logic, a folding flag, and a merging flag as its arguments. op metaSmtSearch : Module Term Term Condition Qid Bound Nat Qid Bool Bool ~&gt; SmtResult2? . ceq metaSmtSearch(M, T, T', COND, STEP, B, N, LOGIC, FOLD, MERGE) = metaSmtSearch(transform(M, VN + N'), makeConstTerm(AT), makeConstTerm(AT'), CND, conj((CD, CD', SMT)), STEP, 0, B, N, LOGIC, FOLD, MERGE) if {AT, CD, VN} := abst(M, T, 0) /\\ {AT', CD', N'} := abst(M, T', VN) /\\ {CND, CND'} := sep(COND) /\\ SMT := $getSmt(CND') . op metaSmtSearch : Module Term Term Condition Qid Bound Nat Qid ~&gt; SmtResult2? . eq metaSmtSearch(M, T, T', COND, STEP, B, N, LOGIC) = metaSmtSearch(M, T, T', COND, STEP, B, N, LOGIC, false, false) . op metaSmtSearch : Module Term Term Condition Qid Bound Nat Qid Bool ~&gt; SmtResult2? . eq metaSmtSearch(M, T, T', COND, STEP, B, N, LOGIC, FOLD) = metaSmtSearch(M, T, T', COND, STEP, B, N, LOGIC, FOLD, false) . op metaSmtSearch : Module Term Term Condition Term Qid Nat Bound Nat Qid Bool Bool ~&gt; SmtResult2? [special (id-hook MetaLevelSmtOpSymbol (metaSmtSearch) op-hook smtFailureSymbol (failure : ~&gt; SmtResult2?) ...)] . metaSmtSearchPath . This function takes the same argument as metaSmtSearch and performs the same search, but returns a path to the solution state. ",
    "url": "/smt-interface#metalevel-functions",
    "relUrl": "/smt-interface#metalevel-functions"
  }
}
