{"0": {
    "doc": "Download",
    "title": "Download",
    "content": " ",
    "url": "/download",
    "relUrl": "/download"
  },"1": {
    "doc": "Download",
    "title": "Table of contents",
    "content": ". | Prerequisite | Installation | How to run Maude-SE | . We provide Python wheels for Maude-SE through our GitHub repository. Please visit https://github.com/maude-se/maude-se/releases/tag/v0.0.1 and download. The followings are the currently available wheels provided on the release page. | File | Description | . | maude_se-0.0.1-cp38-cp38-linux_x86_64.whl | A Python 3.8 wheel of Maude-SE for Linux | . | maude_se-0.0.1-cp39-cp39-linux_x86_64.whl | A Python 3.9 wheel of Maude-SE for Linux | . | maude_se-0.0.1-cp310-cp310-linux_x86_64.whl | A Python 3.10 wheel of Maude-SE for Linux | . | maude_se-0.0.1-cp311-cp311-linux_x86_64.whl | A Python 3.11 wheel of Maude-SE for Linux | . | maude_se-0.0.1-cp312-cp312-linux_x86_64.whl | A Python 3.12 wheel of Maude-SE for Linux | . | maude_se-0.0.1-cp38-cp38-macosx_14_0_arm64.whl | A Python 3.8 wheel of Maude-SE for MacOS | . | maude_se-0.0.1-cp39-cp39-macosx_14_0_arm64.whl | A Python 3.9 wheel of Maude-SE for MacOS | . | maude_se-0.0.1-cp310-cp310-macosx_14_0_arm64.whl | A Python 3.10 wheel of Maude-SE for MacOS | . | maude_se-0.0.1-cp311-cp311-macosx_14_0_arm64.whl | A Python 3.11 wheel of Maude-SE for MacOS | . | maude_se-0.0.1-cp312-cp312-macosx_14_0_arm64.whl | A Python 3.12 wheel of Maude-SE for MacOS | . We also provide a zip file (maude-se.zip). This file contains examples and an installation script. The structure of the zip file is as follows. | File | Description | . | requirements.txt | A list of required Python packages for MaudeSE | . | api-test.py | Example usages of the Maude-SE Python API | . | api-test.maude | A Maude file used by api-test.py | . | smt-check-ex.maude | A Maude file containing examples for metaSmtCheck function | . | smt-search-ex.maude | A Maude file containing examples for metaSmtSearch2 function | . ",
    "url": "/download#table-of-contents",
    "relUrl": "/download#table-of-contents"
  },"2": {
    "doc": "Download",
    "title": "Prerequisite",
    "content": "Maude-SE supports various SMT solvers such as Z3, CVC4, CVC5, and Yices. Maude-SE provides connections to their Python bindings. Among these solvers, The Yices Python binding requires the Yices executable to be installed. Please follow the instructions of https://github.com/SRI-CSL/yices2 to install the Yices executable. ",
    "url": "/download#prerequisite",
    "relUrl": "/download#prerequisite"
  },"3": {
    "doc": "Download",
    "title": "Installation",
    "content": "To install Maude-SE, unzip the maude-se.zip file and go inside the unzipped directory. ~$ unzip maude-se.zip &amp;&amp; cd maude-se . Use the following command to install required Python packages for Maude-SE. ~/maude-se$ pip install -r requirements.txt . Install one of the Maude-SE Python wheels. ~/maude-se$ pip install maude_se-0.0.1-cp&lt;YOUR-PYTHON-VERSION&gt;-cp&lt;YOUR-PYTHON-VERSION&gt;-&lt;YOUR-OS&gt;.whl . Type the following command to test successful installation. ~/maude-se$ maude-se -h . If the installation was successful, you can see the following message. usage: maude-se [-h] [-s [SOLVER]] [-no-meta] [file] positional arguments: file input Maude file options: -h, --help show this help message and exit -s [SOLVER], -solver [SOLVER] set an underlying SMT solver * Supported solvers: {z3,yices,cvc5} * Usage: -s cvc5 * Default: -s z3 -no-meta no metaInterpreter . We built and tested Maude-SE on Ubuntu 20.04 and on M1 MacBook Pro. ",
    "url": "/download#installation",
    "relUrl": "/download#installation"
  },"4": {
    "doc": "Download",
    "title": "How to run Maude-SE",
    "content": "You are now ready to run Maude-SE using the main script maude-se. The script takes an input Maude file and executes it. For example, you can run the example file smt-check-ex.maude with yices solver using the following command. ~/maude-se$ maude-se ./smt-check-ex.maude -s yices . The Maude-SE Python package contains smt-check.maude which includes two meta-level functions: metaSmtCheck and metaSmtSearch2. The metaSmtCheck function can check the satisfiability of SMT queries, as similar to metaCheck, but it can handle various theories (with uninterpreted functions) and generate satisfying assignments. The metaSmtSearch2 function can perform search using rewriting modulo SMT, similar to metaSmtSearch, but supports folding. Currently, we do not support metaSimplify. We will update this later. ",
    "url": "/download#how-to-run-maude-se",
    "relUrl": "/download#how-to-run-maude-se"
  },"5": {
    "doc": "Examples",
    "title": "Examples",
    "content": " ",
    "url": "/examples",
    "relUrl": "/examples"
  },"6": {
    "doc": "Examples",
    "title": "Table of contents",
    "content": ". | Examples . | smt-check-ex.maude | smt-search-ex.maude | Python API | . | Module restrictions | . ",
    "url": "/examples#table-of-contents",
    "relUrl": "/examples#table-of-contents"
  },"7": {
    "doc": "Examples",
    "title": "Examples",
    "content": "We provide two example files, smt-check-ex.maude and smt-search-ex.maude, to show the usage of the two functions. smt-check-ex.maude . In this file, we show the usage of metaSmtCheck using various theories and formulas including interpreted and uninterpreted symbols. The file contains four functional module: SIMPLE, EUF, EUF-ARRAY, EUF-XOR. The SIMPLE module simply imports INTEGER module. The EUF module defines a new sort A and an uninterpreted symbol f. The EUF-ARRAY module connects interpreted symbols from the Array theory to Maude operators. The EUF-XOR is another example for uninterpreted symbol. fmod SIMPLE is pr INTEGER . pr META-SMT-CHECK . endfm fmod EUF is pr BOOLEAN . sort A . op _===_ : A A -&gt; Boolean . op f : A -&gt; A [ctor metadata \"smt euf\"] . endfm fmod ARRAY is pr REAL-INTEGER . sort Array{Integer,Integer} . op _===_ : Array{Integer,Integer} Array{Integer,Integer} -&gt; Boolean . op select : Array{Integer,Integer} Integer -&gt; Integer [metadata \"smt array:select\"] . op _[_] : Array{Integer,Integer} Integer -&gt; Integer [metadata \"smt array:select\"] . op store : Array{Integer,Integer} Integer Integer -&gt; Array{Integer,Integer} [metadata \"smt array:store\"] . endfm fmod EUF-XOR is pr INTEGER . op _xor_ : Integer Integer -&gt; Integer [metadata \"smt euf\"] . endfm . As the modules EUF and EUF-XOR show, we can declare uninterpreted symbols by declaring operators and annotating them as uninterpreted symbols using the metadata attribute. For example, the uninterpreted symbol f of EUF is annotated with metadata smt euf, meaning that the operator is an SMT symbol (smt) and an uninterpreted symbol (euf). Another module ARRAY show how to connect interpreted symbol to Maude. We also use the metadata attribute. For example, we use the metadata smt array:select to denote the interpreted symbol select of the array theory. In addition, we can connect a single interpreted symbol to different Maude operators. For example, we connect the select to select and _[_] in the ARRAY module. To use metaSmtCheck, we need to import META-SMT-CHECK module. Then, we can check the satisfiability of various formulas under EUF and Array theories as follows. red metaSmtCheck(upModule('INTEGER, false), upTerm(X:Integer &gt; 4), 'QF_LRA, true) . red metaSmtCheck(upModule('REAL, false), upTerm(X:Real &gt; 4/3), 'QF_LRA, true) . red metaSmtCheck(upModule('BOOLEAN, false), upTerm(B:Boolean), 'QF_LRA, true) . red metaSmtCheck(upModule('EUF, false), upTerm(f(f(X)) === X and f(X) === Y and not (X === Y)), 'QF_UF) . red metaSmtCheck(upModule('ARRAY, false), upTerm(select(A1, X) === X and store(A1, X, Y) === A1), 'QF_AUFLIA) . red metaSmtCheck(upModule('ARRAY, false), upTerm(A1[X] === X and store(A1, X, Y) === A1), 'QF_AUFLIA) . red metaSmtCheck(upModule('EUF-XOR, false), upTerm(not(N === 0) and 0 &lt;= N and 0 &lt;= (N xor 255) and N &lt; 256 and not (0 &lt;= (N xor 255))), 'QF_UFLIA) . red metaSmtCheck(upModule('EUF-XOR, false), upTerm(0 &lt;= (N xor 255)), 'QF_UFLIA) . red metaSmtCheck(upModule('EUF-XOR, false), upTerm(0 &lt;= (N xor 255)), 'QF_UFLIA, true) . --- generating a satisfying assignment . The usage of metaSmtCheck is similar to metaCheck except that it takes an SMT logic and a boolean flag as its arguments, where the flag decides whether to generate a satisfying assignment for the satisfiable case. op metaSmtCheck : Module Term Qid -&gt; SmtCheckResult . eq metaSmtCheck(M:Module, TERM:Term, LOGIC:Qid) = metaSmtCheck(M:Module, TERM:Term, LOGIC:Qid, false) . op metaSmtCheck : Module Term Qid Bool -&gt; SmtCheckResult [special (id-hook SpecialHubSymbol (SmtCheckerSymbol) op-hook unknownResultSymbol (unknown : ~&gt; SmtCheckResult) op-hook smtAssignmentResultSymbol ({_} : SatAssignmentSet ~&gt; SmtCheckResult) op-hook emptySatAssignmentSetSymbol (empty : ~&gt; SatAssignmentSet) op-hook concatSatAssignmentSetSymbol (_,_ : SatAssignmentSet SatAssignmentSet ~&gt; SatAssignmentSet) op-hook assnPairSymbol (_|-&gt;_ : Term Term ~&gt; SatAssignment) term-hook builtinTrueTerm ((true).Bool) term-hook builtinFalseTerm ((false).Bool) )] . The check result is given as a term of sort SmtCheckResult, which can be one of unknown, true, false, or {_}. The symbol {_} consists of a set of assignments, where each assignment is denoted as a term _|-&gt;_. sort SmtCheckResult . subsort Bool &lt; SmtCheckResult . op unknown : -&gt; SmtCheckResult [ctor] . op {_} : SatAssignmentSet -&gt; SmtCheckResult [ctor] . sort SatAssignment . op _|-&gt;_ : Term Term -&gt; SatAssignment [ctor] . sort SatAssignmentSet . subsort SatAssignment &lt; SatAssignmentSet . op empty : -&gt; SatAssignmentSet [ctor] . op _,_ : SatAssignmentSet SatAssignmentSet -&gt; SatAssignmentSet [ctor comm assoc id: empty] . We can run the smt-check-ex.maude file with CVC5 using the following command: . ~/maude-se-linux$ maude-se smt-check-ex.maude -s cvc5 . The results are as follows. ========================================== reduce in SIMPLE : metaSmtCheck(upModule('INTEGER, false), upTerm(X:Integer &gt; (4).Integer), 'QF_LRA, true) . rewrites: 1 result SmtCheckResult: {'X:Integer |-&gt; '5.Integer} ========================================== reduce in SIMPLE : metaSmtCheck(upModule('REAL, false), upTerm(X:Real &gt; 4/3), 'QF_LRA, true) . rewrites: 1 result SmtCheckResult: {'X:Real |-&gt; '7/3.Real} ========================================== reduce in SIMPLE : metaSmtCheck(upModule('BOOLEAN, false), upTerm(B:Boolean), 'QF_LRA, true) . rewrites: 1 result SmtCheckResult: {'B:Boolean |-&gt; 'true.Boolean} ========================================== reduce in EUF-CHECK : metaSmtCheck(upModule('EUF, false), upTerm(f(f(X)) === X and f(X) === Y and not X === Y), 'QF_UF) . rewrites: 4 result Bool: (true).Bool ========================================== reduce in ARRAY-CHECK : metaSmtCheck(upModule('ARRAY, false), upTerm(select(A1, X) === X and store(A1, X, Y) === A1), 'QF_AUFLIA) . rewrites: 4 in 1ms cpu (1ms real) (2619 rewrites/second) result Bool: (true).Bool ========================================== reduce in ARRAY-CHECK : metaSmtCheck(upModule('ARRAY, false), upTerm(A1[X] === X and store(A1, X, Y) === A1), 'QF_AUFLIA) . rewrites: 4 result Bool: (true).Bool ========================================== reduce in EUF-XOR-CHECK : metaSmtCheck(upModule('EUF-XOR, false), upTerm(not N === (0).Integer and (0).Integer &lt;= N and (0).Integer &lt;= (N xor (255).Integer) and N &lt; (256).Integer and not (0).Integer &lt;= (N xor (255).Integer)), 'QF_UFLIA) . rewrites: 4 result Bool: (false).Bool ========================================== reduce in EUF-XOR-CHECK : metaSmtCheck(upModule('EUF-XOR, false), upTerm((0).Integer &lt;= (N xor (255).Integer)), 'QF_UFLIA) . rewrites: 4 result Bool: (true).Bool ========================================== reduce in EUF-XOR-CHECK : metaSmtCheck(upModule('EUF-XOR, false), upTerm((0).Integer &lt;= (N xor (255).Integer)), 'QF_UFLIA, true) . rewrites: 1 result SmtCheckResult: {('N:Integer |-&gt; '1.Integer),{\"_xor_\" |-&gt; \"(lambda ((_arg_1 Int) (_arg_2 Int)) 0)\"}} ========================================== . smt-search-ex.maude . This file provides examples of metaSmtSearch2 using gcd and robot examples. mod GCD is pr INTEGER . sorts GcdResult . op gcd : Integer Integer -&gt; GcdResult [ctor] . op return : Integer -&gt; GcdResult [ctor] . vars X Y : Integer . crl [r1] : gcd(X, Y) =&gt; gcd(X - Y, Y) if X &gt; Y = true [nonexec] . crl [r2] : gcd(X, Y) =&gt; gcd(X, Y - X) if X &lt; Y = true [nonexec] . crl [r3] : gcd(X, Y) =&gt; return (X) if X === Y = true [nonexec] . endm omod ROBOT is pr REAL . class Robot | pos : Vector, vel : Vector, acc : Vector, time : Real . sort Vector . op [_,_] : Real Real -&gt; Vector [ctor] . endom omod ROBOT-DYNAMICS is pr ROBOT . vars O : Oid . vars CONST CONST' : Boolean . vars PX VX AX PY VY AY PX' VX' AX' PY' VY' AY' T T' TAU : Real . crl [move]: &lt; O : Robot | pos : [PX, PY], vel : [VX, VY], acc : [AX, AY], time : T &gt; =&gt; &lt; O : Robot | pos : [PX', PY'], vel : [VX', VY'], time : T + TAU &gt; if TAU &gt;= 0/1 and VX' === VX + AX * TAU and VY' === VY + AY * TAU and PX' === 1/2 * AX * TAU * TAU + VX * TAU + PX and PY' === 1/2 * AY * TAU * TAU + VY * TAU + PY = true [nonexec] . crl [accX]: &lt; O : Robot | acc : [AX, AY] &gt; =&gt; &lt; O : Robot | acc : [AX', AY] &gt; if AY === 0/1 = true [nonexec] . crl [accY]: &lt; O : Robot | acc : [AX, AY] &gt; =&gt; &lt; O : Robot | acc : [AX, AY'] &gt; if AX === 0/1 = true [nonexec] . op r : -&gt; Oid [ctor] . endom . To use metaSmtSearch2, we need to import META-SMT-SEARCH2 module. The following commands show how to perform rewriting modulo SMT. --- gcd(10, I) =&gt;* return(J) such that I &lt; 9 and I &gt; 0 = true . red metaSmtSearch2(upModule('GCD, false), upTerm(gcd(10, I)), upTerm(return(J)), upTerm(I &lt; 9 and I &gt; 0) = upTerm((true).Bool), '=&gt;*, unbounded, 8, 'QF_LRA) . red metaSmtSearch2(upModule('ROBOT-DYNAMICS, false), upTerm(&lt; r : Robot | pos : [IPX, IPY], vel : [IVX, IVY], acc : [IAX, IAY], time : CLK &gt;), upTerm(&lt; r : Robot | pos : [NPX, NPY], ATTRSET &gt;), upTerm(NPX === 10/1 and NPY === 10/1 and IPX === 0/1 and IPY === 0/1 and IVX === 0/1 and IVY === 0/1 and IAX === 0/1 and IAY === 0/1 and CLK === 0/1) = upTerm((true).Bool), '=&gt;*, unbounded, 1, 'QF_NRA) . The first command searches for the 8-th solution term that matches return(J) and satisfies the consition I &lt; 9 and I &gt; 0, starting from an initial term gcd(10, I) without folding under the QF_LRA logic. The second command searches for the first solution, with the QF_NRA logic, that matches the goal pattern &lt; r : Robot | pos : [NPX, NPY], ATTRSET &gt; and satisfies the consition NPX === 10/1 and NPY === 10/1, starting from an initial term, where all its attributes are zeros. The metaSmtSearch2 is similar to metaSmtSearch except that it takes a logic and a folding flag as its arguments. op metaSmtSearch2 : Module Term Term Condition Qid Bound Nat Qid Bool Bool -&gt; SmtResult? . eq metaSmtSearch2(M, T, T', COND, STEP, B, N, LOGIC, FOLD, MERGE) = metaSmtSearchInternal(transform(M), makeConstTerm(T), makeConstTerm(T'), COND, STEP, B, N, LOGIC, FOLD, MERGE) . op metaSmtSearch2 : Module Term Term Condition Qid Bound Nat Qid -&gt; SmtResult? . eq metaSmtSearch2(M, T, T', COND, STEP, B, N, LOGIC) = metaSmtSearch2(M, T, T', COND, STEP, B, N, LOGIC, false, false) . op metaSmtSearch2 : Module Term Term Condition Qid Bound Nat Qid Bool -&gt; SmtResult? . eq metaSmtSearch2(M, T, T', COND, STEP, B, N, LOGIC, FOLD) = metaSmtSearch2(M, T, T', COND, STEP, B, N, LOGIC, FOLD, false) . op metaSmtSearchInternal : Module Term Term Condition Qid Bound Nat Qid Bool Bool -&gt; SmtResult? [special (id-hook SpecialHubSymbol (SmtSearchSymbol) op-hook failureSymbol (failure : ~&gt; SmtResult?) op-hook resultSymbol ({_,_,_,_} : Term Substitution Term Nat ~&gt; SmtResult))]. We can run the smt-search-ex.maude file with Yices using the following command: . ~/maude-se-linux$ maude-se smt-search-ex.maude -s yices . The search results are as follows. ========================================== reduce metaSmtSearch2(upModule('GCD, false), upTerm(gcd((10).Integer, I)), upTerm(return(J)), upTerm(I &lt; (9).Integer and I &gt; (0).Integer) = upTerm((true).Bool), '=&gt;*, unbounded, 8, 'QF_LRA) . result SmtResult2: {'return['%%ubVar$9:Integer], '%%ubVar$1:Integer &lt;- '9.Integer ; '%%ubVar$2:Integer &lt;- '8.Integer ; '%%ubVar$3:Integer &lt;- '7.Integer ; '%%ubVar$4:Integer &lt;- '6.Integer ; '%%ubVar$5:Integer &lt;- '5.Integer ; '%%ubVar$6:Integer &lt;- '4.Integer ; '%%ubVar$7:Integer &lt;- '3.Integer ; '%%ubVar$8:Integer &lt;- '2.Integer ; '%%ubVar$9:Integer &lt;- '1.Integer ; 'I:Integer &lt;- '1.Integer ; 'J:Integer &lt;- '1.Integer, 'return['1.Integer], '_or_[...], 26} ========================================== red metaSmtSearch2(upModule('ROBOT-DYNAMICS, false), upTerm(&lt; r : Robot | pos : [IPX, IPY], vel : [IVX, IVY], acc : [IAX, IAY], time : CLK &gt;), upTerm(&lt; r : Robot | pos : [NPX, NPY], ATTRSET &gt;), upTerm(NPX === 10/1 and NPY === 10/1 and IPX === 0/1 and IPY === 0/1 and IVX === 0/1 and IVY === 0/1 and IAX === 0/1 and IAY === 0/1 and CLK === 0/1) = upTerm((true).Bool), '=&gt;*, unbounded, 1, 'QF_NRA) . result SmtResult2: {'&lt;_:_|_&gt;[...], '%%ubVar$10:Real &lt;- '10/1.Real ; '%%ubVar$11:Real &lt;- '10/1.Real ; '%%ubVar$12:Real &lt;- '20/3.Real ; '%%ubVar$13:Real &lt;- '20/1.Real ; '%%ubVar$14:Real &lt;- '2/1.Real ; '%%ubVar$15:Real &lt;- '1/1.Real ; '%%ubVar$1:Real &lt;- '20/3.Real ; '%%ubVar$2:Real &lt;- '10/3.Real ; '%%ubVar$3:Real &lt;- '0/1.Real ; '%%ubVar$4:Real &lt;- '20/3.Real ; '%%ubVar$5:Real &lt;- '0/1.Real ; '%%ubVar$6:Real &lt;- '1/1.Real ; '%%ubVar$7:Real &lt;- '1/1.Real ; '%%ubVar$8:Real &lt;- '0/1.Real ; '%%ubVar$9:Real &lt;- '20/1.Real ; 'CLK:Real &lt;- '0/1.Real ; 'IAX:Real &lt;- '0/1.Real ; 'IAY:Real &lt;- '0/1.Real ; 'IPX:Real &lt;- '0/1.Real ; 'IPY:Real &lt;- '0/1.Real ; 'IVX:Real &lt;- '0/1.Real ; 'IVY:Real &lt;- '0/1.Real ; 'NPX:Real &lt;- '10/1.Real ; 'NPY:Real &lt;- '10/1.Real, '&lt;_:_|_&gt;[...], 180} . In the current alpha version, the number of rewrites reported by metaSmtSearch2 is incorrect. As we need to explore 180 states to find reachable state for robot example, we can reduce the search space by enabling folding as follows. red metaSmtSearch2(upModule('ROBOT-DYNAMICS, false), upTerm(&lt; r : Robot | pos : [IPX, IPY], vel : [IVX, IVY], acc : [IAX, IAY], time : CLK &gt;), upTerm(&lt; r : Robot | pos : [NPX, NPY], ATTRSET &gt;), upTerm(NPX === 10/1 and NPY === 10/1 and IPX === 0/1 and IPY === 0/1 and IVX === 0/1 and IVY === 0/1 and IAX === 0/1 and IAY === 0/1 and CLK === 0/1) = upTerm((true).Bool), '=&gt;*, unbounded, 1, 'QF_NRA, true) . ========================================== result SmtResult2: {'&lt;_:_|_&gt;[...], '%%ubVar$10:Real &lt;- '10/1.Real ; '%%ubVar$11:Real &lt;- '10/1.Real ; '%%ubVar$12:Real &lt;- '20/3.Real ; '%%ubVar$13:Real &lt;- '20/1.Real ; '%%ubVar$14:Real &lt;- '2/1.Real ; '%%ubVar$15:Real &lt;- '1/1.Real ; '%%ubVar$1:Real &lt;- '20/3.Real ; '%%ubVar$2:Real &lt;- '10/3.Real ; '%%ubVar$3:Real &lt;- '0/1.Real ; '%%ubVar$4:Real &lt;- '20/3.Real ; '%%ubVar$5:Real &lt;- '0/1.Real ; '%%ubVar$6:Real &lt;- '1/1.Real ; '%%ubVar$7:Real &lt;- '1/1.Real ; '%%ubVar$8:Real &lt;- '0/1.Real ; '%%ubVar$9:Real &lt;- '20/1.Real ; 'CLK:Real &lt;- '0/1.Real ; 'IAX:Real &lt;- '0/1.Real ; 'IAY:Real &lt;- '0/1.Real ; 'IPX:Real &lt;- '0/1.Real ; 'IPY:Real &lt;- '0/1.Real ; 'IVX:Real &lt;- '0/1.Real ; 'IVY:Real &lt;- '0/1.Real ; 'NPX:Real &lt;- '10/1.Real ; 'NPY:Real &lt;- '10/1.Real, '&lt;_:_|_&gt;[...], 37} . The result shows that we could find the solution by exploring only 37 states. Python API . Since we use Maude-as-a-library to implement Maude-SE, we also provide the Python API for Maude-SE by using the Python implementation. For example, the api-test.py file shows how to perform SMT search for the gcd and robot examples using the Python API. See our api-test.py for more details. import maude ... from maudeSE.api import * # import our Python API maude.init(advise=False) maude.load(os.path.join(os.path.dirname(__file__), '.', 'api-test.maude')) gcd = maude.getModule('GCD') init = gcd.parseTerm('gcd(10, I:Integer)') goal = gcd.parseTerm('return(J:Integer)') c = maude.EqualityCondition(gcd.parseTerm('I:Integer &lt; 9 and I:Integer &gt; 0'), gcd.parseTerm('(true).Bool')) gcd_result = smtSearch2(gcd, init, goal, c, \"=&gt;*\", \"unbounded\", 8, False) print(gcd_result) . The arguments of the smtSearch2 function are not meta-level terms. We can run the test file api-test.py using the following command: . python3 api-test.py . The result are as follows. {'return['#ubVar$9:Integer], '#newVar$0:Integer &lt;- '1.Integer ; '#ubVar$1:Integer &lt;- '9.Integer ; '#ubVar$2:Integer &lt;- '8.Integer ; '#ubVar$3:Integer &lt;- '7.Integer ; '#ubVar$4:Integer &lt;- '6.Integer ; '#ubVar$5:Integer &lt;- '5.Integer ; '#ubVar$6:Integer &lt;- '4.Integer ; '#ubVar$7:Integer &lt;- '3.Integer ; '#ubVar$8:Integer &lt;- '2.Integer ; '#ubVar$9:Integer &lt;- '1.Integer ; 'I:Integer &lt;- '1.Integer ; 'J:Integer &lt;- '1.Integer,'return['1.Integer], ..., 26} ========================================== {'&lt;_:_|_&gt;[...], '%%ubVar$10:Real &lt;- '10/1.Real ; '%%ubVar$11:Real &lt;- '10/1.Real ; '%%ubVar$12:Real &lt;- '20/3.Real ; '%%ubVar$13:Real &lt;- '20/1.Real ; '%%ubVar$14:Real &lt;- '2/1.Real ; '%%ubVar$15:Real &lt;- '1/1.Real ; '%%ubVar$1:Real &lt;- '20/3.Real ; '%%ubVar$2:Real &lt;- '10/3.Real ; '%%ubVar$3:Real &lt;- '0/1.Real ; '%%ubVar$4:Real &lt;- '20/3.Real ; '%%ubVar$5:Real &lt;- '0/1.Real ; '%%ubVar$6:Real &lt;- '1/1.Real ; '%%ubVar$7:Real &lt;- '1/1.Real ; '%%ubVar$8:Real &lt;- '0/1.Real ; '%%ubVar$9:Real &lt;- '20/1.Real ; 'CLK:Real &lt;- '0/1.Real ; 'IAX:Real &lt;- '0/1.Real ; 'IAY:Real &lt;- '0/1.Real ; 'IPX:Real &lt;- '0/1.Real ; 'IPY:Real &lt;- '0/1.Real ; 'IVX:Real &lt;- '0/1.Real ; 'IVY:Real &lt;- '0/1.Real ; 'NPX:Real &lt;- '10/1.Real ; 'NPY:Real &lt;- '10/1.Real,'&lt;_:_|_&gt;[...],180} ========================================== {'&lt;_:_|_&gt;[...], '%%ubVar$10:Real &lt;- '10/1.Real ; '%%ubVar$11:Real &lt;- '10/1.Real ; '%%ubVar$12:Real &lt;- '20/3.Real ; '%%ubVar$13:Real &lt;- '20/1.Real ; '%%ubVar$14:Real &lt;- '2/1.Real ; '%%ubVar$15:Real &lt;- '1/1.Real ; '%%ubVar$1:Real &lt;- '20/3.Real ; '%%ubVar$2:Real &lt;- '10/3.Real ; '%%ubVar$3:Real &lt;- '0/1.Real ; '%%ubVar$4:Real &lt;- '20/3.Real ; '%%ubVar$5:Real &lt;- '0/1.Real ; '%%ubVar$6:Real &lt;- '1/1.Real ; '%%ubVar$7:Real &lt;- '1/1.Real ; '%%ubVar$8:Real &lt;- '0/1.Real ; '%%ubVar$9:Real &lt;- '20/1.Real ; 'CLK:Real &lt;- '0/1.Real ; 'IAX:Real &lt;- '0/1.Real ; 'IAY:Real &lt;- '0/1.Real ; 'IPX:Real &lt;- '0/1.Real ; 'IPY:Real &lt;- '0/1.Real ; 'IVX:Real &lt;- '0/1.Real ; 'IVY:Real &lt;- '0/1.Real ; 'NPX:Real &lt;- '10/1.Real ; 'NPY:Real &lt;- '10/1.Real,'&lt;_:_|_&gt;[...],37} . ",
    "url": "/examples",
    "relUrl": "/examples"
  },"8": {
    "doc": "Examples",
    "title": "Module restrictions",
    "content": "Currently, we make several restrictions to rewrite rules and equations: . | Rewrite rules should not have non-SMT constraints in their conditions. | Equations should not contradict or conflict with SMT theories. | When defining and connecting SMT symbols using metadata, one should not use equational axiom attritues (e.g., assoc, comm, id) and the metadata attributes together. | . ",
    "url": "/examples#module-restrictions",
    "relUrl": "/examples#module-restrictions"
  },"9": {
    "doc": "Home",
    "title": "About Maude SE",
    "content": "Maude-SE is a rewriting modulo SMT extension of Maude, which is a flexible yet efficient framework for connecting SMT solvers to Maude. It supports symbolic reachability analysis with folding, an SMT check with various SMT theories, and an abstract connector at the Python level that makes it easy to integrate and customize SMT solving, without having to understand Maude’s internal implementation. Get started now . ",
    "url": "/#about-maude-se",
    "relUrl": "/#about-maude-se"
  },"10": {
    "doc": "Home",
    "title": "Bug report",
    "content": "To report bugs (or provide any suggestions), please contact maude-se@postech.ac.kr. ",
    "url": "/#bug-report",
    "relUrl": "/#bug-report"
  },"11": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    "relUrl": "/"
  },"12": {
    "doc": "Previous Version",
    "title": "Previous Version of Maude-SE",
    "content": " ",
    "url": "/old#previous-version-of-maude-se",
    "relUrl": "/old#previous-version-of-maude-se"
  },"13": {
    "doc": "Previous Version",
    "title": "Table of contents",
    "content": ". | About Maude SE | Getting started | How to Cite | Download . | Supported Version | . | SMT Interface . | Full Maude Interface . | Search Command | Usage | . | Core Maude Interface . | Core Maude Functions | Usage | . | . | Examples . | Full Maude Robot | GCD | Robot | . | . ",
    "url": "/old#table-of-contents",
    "relUrl": "/old#table-of-contents"
  },"14": {
    "doc": "Previous Version",
    "title": "About Maude SE",
    "content": "Maude SE is a rewriting modulo SMT extension of Maude at C++ level. It provides a Maude user interface to specify an SMT formula with equations and rules and can generate a set of concrete assignments when the formula is satisfied. Currently supported SMT solvers are Z3, Yices2, CVC4, and dReal. Get started now Paper . Maude-SE is an SMT extension of Maude that tightly integrates Maude and SMT solvers with extra functionality. It extends the original Maude-SMT at core Maude level. In addition to the existing SMT solving capability of Maude, the tool provides three additional features that are not currently supported by Maude but that are very useful for rewriting modulo SMT: . | building satisfying assignments by SMT solving, | simplifying formulas using the underlying SMT solver, and | dealing with non-linear arithmetic formulas. | . Maude-SE can analyze nontrivial systems that cannot be dealt with by the previous Maude-SMT implementation. There are three versions of Maude SE (i.e., Z3, Yices2, CVC4), depending on an underlying SMT solver it uses. ",
    "url": "/old#about-maude-se",
    "relUrl": "/old#about-maude-se"
  },"15": {
    "doc": "Previous Version",
    "title": "Getting started",
    "content": "To use Maude SE, please follow the instructions below: . | Download one of the zip files from here (e.g., maude-se-z3.tar.gz). | Extract the zip file to somewhere you want. # you can see `smt-check.maude` at the top directory. $ tar -xvzf maude-se-z3.tar.gz &amp;&amp; cd maude-se-z3 . | Load or include smt-check.maude in your own module. | . ",
    "url": "/old#getting-started",
    "relUrl": "/old#getting-started"
  },"16": {
    "doc": "Previous Version",
    "title": "How to Cite",
    "content": "To cite our paper, use the following bibtex format or refer to the google scholar. @article{yu2020maude, title={Maude-SE: A tight integration of Maude and SMT solvers}, author={Yu, Geunyeol and Bae, Kyungmin}, journal={Rewriting Logic and its Applications}, pages={220}, year={2020} } . ",
    "url": "/old#how-to-cite",
    "relUrl": "/old#how-to-cite"
  },"17": {
    "doc": "Previous Version",
    "title": "Download",
    "content": "Maude-SE currently supports three major SMT solvers: Z3, Yices2 (a variation of Yices solver Yices2-mcsat), and CVC4. Maude-SE with Z3, Yices2-mcsat, and CVC4 support quantifier free nonlinear theories as well as linear theories, while Yices only supports linear ones. We will going to support dReal SMT solver (dReal3 and dReal4) in the future. Supported Version . | # | Name | Files | . | 1 | maude-se-z3 | [MacOS][Ubuntu] | . | 2 | maude-se-yices2 | [MacOS][Ubuntu] | . | 3 | maude-se-yices2-mcsat | [MacOS][Ubuntu] | . | 4 | maude-se-cvc4 | [MacOS][Ubuntu] | . | 5 | maude-se-dreal4 |   | . Currently, we support Maude-SE executables for Linux 64 bits only. We will provide executables for MacOS later. ",
    "url": "/old#download",
    "relUrl": "/old#download"
  },"18": {
    "doc": "Previous Version",
    "title": "SMT Interface",
    "content": "Full Maude Interface . The Full Maude interface of Maude SE provides smt-search2 command for symbolic reachability analysis. Search Command . Given an initial state t, a goal pattern u, and a goal condition cond, the following command searches for n states that are reachable within m rewrite steps from the initial state t, match the goal pattern u, and satisfy the goal condition cond. (smt-search2 [n, m] in M : t =&gt;* u such that cond.) . Usage . To see the usage of this command, refer to the Maude-SE paper for more details. For the simple usage of the command, see the full/robot.maude example. Core Maude Interface . The main functionality of the Maude SE is implemented in the predefined functional module SMT-CHECK which also contains signatures for both SMT formulas and their solutions. The interface contains two main functions in the module SMT-CHECK: . | smtCheck for checking the satisfiability of an SMT formula, and | simplifyFormula for simplifying the formula. | . Core Maude Functions . op smtCheck : BooleanExpr -&gt; SmtCheckResult . eq smtCheck(BE:BooleanExpr) = smtCheck(BE:BooleanExpr, false) . op smtCheck : BooleanExpr Bool -&gt; SmtCheckResult [special ... )] . op simplifyFormula : BooleanExpr -&gt; BooleanExpr [special ... )] . op simplifyFormula : IntegerExpr -&gt; IntegerExpr [special ... )] . op simplifyFormula : RealExpr -&gt; RealExpr [special ... )] . Usage . To see the usages of these functions, see gcd.maude and robot.maude examples. ",
    "url": "/old#smt-interface",
    "relUrl": "/old#smt-interface"
  },"19": {
    "doc": "Previous Version",
    "title": "Examples",
    "content": "We provide three examples: robot-full.maude, gcd.maude, and robot.maude. Full Maude Robot . (omod ROBOT-DYNAMICS is pr REAL . inc CONFIGURATION . sort Vector . op `[_`,_`] : Real Real -&gt; Vector [ctor] . sorts RobotTraceItem RobotTrace . subsort Vector &lt; RobotTraceItem &lt; RobotTrace . op ==`(_:_`)==&gt; : Vector Real -&gt; RobotTraceItem [ctor] . op __ : RobotTrace RobotTrace -&gt; RobotTrace [ctor assoc] . class Robot | pos : Vector, vel : Vector, acc : Vector, clock : Real, trace : RobotTrace . sort State . op r : -&gt; Oid [ctor] . subsort Configuration &lt; State . vars O : Oid . vars PX VX AX PY VY AY PX' VX' AX' PY' VY' AY' T T' TAU : Real . var ATTS : AttributeSet . var TRACE : RobotTrace . crl [move]: &lt; O : Robot | pos : [PX, PY], vel : [VX, VY], acc : [AX, AY], clock : T, trace : TRACE &gt; =&gt; &lt; O : Robot | pos : [PX', PY'], vel : [VX', VY'], clock : T + TAU, trace : TRACE ==([VX', VY'] : T + TAU)==&gt; [PX', PY'] &gt; if VX' = VX + AX * TAU /\\ VY' = VY + AY * TAU /\\ PX' = 1/2 * AX * TAU * TAU + VX * TAU + PX /\\ PY' = 1/2 * AY * TAU * TAU + VY * TAU + PY /\\ TAU &gt;= 0/1 = true [nonexec] . crl [accX]: &lt; O : Robot | acc : [AX, AY] &gt; =&gt; &lt; O : Robot | acc : [AX', AY] &gt; if AY = 0/1 [nonexec] . crl [accY]: &lt; O : Robot | acc : [AX, AY] &gt; =&gt; &lt; O : Robot | acc : [AX, AY'] &gt; if AX = 0/1 [nonexec] . endom) (smt-search2 [1] &lt; r : Robot | pos : [0/1, 0/1], vel : [0/1, 0/1], acc : [0/1, 0/1], clock : 0/1, trace : [0/1, 0/1] &gt; =&gt;* &lt; r : Robot | pos : [10/1, 10/1] &gt; .) . To run the full-maude robot example using Z3 binding of Maude SE, go to the top directory (where the exectuable is placed) and type the following command: . $ ./maude-se-z3 examples/full/robot.maude . GCD . mod GCD is protecting INTEGER-EXPR . pr SMT-CHECK . pr META-LEVEL . ops a b : -&gt; SMTVarId [ctor] . sort GcdResult . op gcd : IntegerExpr IntegerExpr -&gt; GcdResult [ctor] . op ret : IntegerExpr -&gt; GcdResult [ctor] . sort State . op {_,_} : BooleanExpr GcdResult -&gt; State [ctor] . vars CONST CONST' : BooleanExpr . vars X Y : IntegerExpr . var SS : SatAssignmentSet . crl {CONST, gcd(X, Y)} =&gt; {simplifyFormula(CONST'), gcd(X - Y, Y)} if CONST' := CONST and (X &gt; Y) === (true).Boolean / smtCheck(CONST', false) . crl {CONST, gcd(X, Y)} =&gt; {simplifyFormula(CONST'), gcd(X, Y - X)} if CONST' := CONST and (X &lt; Y) === (true).Boolean / smtCheck(CONST', false) . crl {CONST, gcd(X, Y)} =&gt; {simplifyFormula(CONST'), ret(X)} if CONST' := CONST and (X === Y) === (true).Boolean / smtCheck(CONST', false) . endm search [1] {true, gcd(i(a), i(b))} =&gt;* {CONST, ret(NN:IntegerExpr)} such that CONST' := CONST and i(a) + i(b) === 27 and NN:IntegerExpr === 3 /\\ smtCheck(CONST') = (true).Bool . To run the GCD example using Z3 binding of Maude SE, go to top directory (whre the executable is placed) and type the following command: . $ ./maude-se-z3 examples/gcd.maude . Robot . mod ROBOT is pr REAL-EXPR . inc CONFIGURATION . sort Robot . subsort Robot &lt; Cid . op Robot : -&gt; Robot [ctor format(! o)] . op pos`:_ : Vector -&gt; Attribute [ctor gather(&amp;)] . op vel`:_ : Vector -&gt; Attribute [ctor gather(&amp;)] . op acc`:_ : Vector -&gt; Attribute [ctor gather(&amp;)] . op time`:_ : RealExpr -&gt; Attribute [ctor gather(&amp;)] . sort Vector . op [_,_] : RealExpr RealExpr -&gt; Vector [ctor] . endm mod ROBOT-DYNAMICS is pr ROBOT . pr SMT-CHECK . inc NAT . pr META-LEVEL . sort State . subsort Nat &lt; SMTVarId . op {_,_,_} : BooleanExpr Nat Configuration -&gt; State [ctor] . var N : Nat . vars O : Oid . vars CONST CONST' : BooleanExpr . vars PX VX AX PY VY AY PX' VX' AX' PY' VY' AY' T T' TAU : RealExpr . var ATTS : AttributeSet . crl [move]: {CONST, N, &lt; O : C:Robot | pos : [PX, PY], vel : [VX, VY], acc : [AX, AY], time : T, ATTS &gt;} =&gt; {CONST', N + 5, &lt; O : C:Robot | pos : [PX', PY'], vel : [VX', VY'], acc : [AX, AY], time : T + TAU, ATTS &gt;} if TAU := r(N) /\\ [PX', PY'] := [r(N + 1), r(N + 2)] /\\ [VX', VY'] := [r(N + 3), r(N + 4)] /\\ CONST' := simplifyFormula(CONST and TAU &gt;= toReal(0) and VX' === VX + AX * TAU and VY' === VY + AY * TAU and PX' === 1/2 * AX * TAU * TAU + VX * TAU + PX and PY' === 1/2 * AY * TAU * TAU + VY * TAU + PY) /\\ smtCheck(CONST') . crl [accX]: {CONST, N, &lt; O : C:Robot | acc : [AX, AY], ATTS &gt;} =&gt; {CONST', s N, &lt; O : C:Robot | acc : [AX', AY], ATTS &gt;} if AX' := r(N) /\\ CONST' := simplifyFormula(CONST and AY === toReal(0)) /\\ smtCheck(CONST') . crl [accY]: {CONST, N, &lt; O : C:Robot | acc : [AX, AY], ATTS &gt;} =&gt; {CONST', s N, &lt; O : C:Robot | acc : [AX, AY'], ATTS &gt;} if AY' := r(N) /\\ CONST' := simplifyFormula(CONST and AX === toReal(0)) /\\ smtCheck(CONST') . endm mod ROBOT-ANALYSIS is inc ROBOT-DYNAMICS . var N : Nat . vars CONST : BooleanExpr . vars PX VX AX PY VY AY T : RealExpr . var SS : SatAssignmentSet . var OBJ : Object . var ATTS : AttributeSet . op r : -&gt; Oid [ctor] . endm search [1] {true, 0, &lt; r : Robot | pos : [toReal(0), toReal(0)], vel : [toReal(0), toReal(0)], acc : [toReal(0), toReal(0)], time : toReal(0) &gt;} =&gt;* {CONST, N, &lt; r : Robot | pos : [PX, PY], ATTS &gt;} such that {SS} := smtCheck(CONST and PX === 10/1 and PY === 10/1, true) . To run the robot example using Z3 binding of Maude SE, go to top directory (whre the executable is placed) and type the following command: . $ ./maude-se-z3 examples/robot.maude . ",
    "url": "/old#examples",
    "relUrl": "/old#examples"
  },"20": {
    "doc": "Previous Version",
    "title": "Previous Version",
    "content": " ",
    "url": "/old",
    "relUrl": "/old"
  },"21": {
    "doc": "SMT Interface",
    "title": "SMT Interface",
    "content": " ",
    "url": "/smt-interface",
    "relUrl": "/smt-interface"
  },"22": {
    "doc": "SMT Interface",
    "title": "Table of contents",
    "content": ". | Analysis Commands . | check | show model | smt-search | show smt-path | . | Metalevel Functions . | metaSmtCheck | metaSmtSearch2 | metaSmtSearch2Path | . | . ",
    "url": "/smt-interface#table-of-contents",
    "relUrl": "/smt-interface#table-of-contents"
  },"23": {
    "doc": "SMT Interface",
    "title": "Analysis Commands",
    "content": "Maude-SE provides various analysis commands, including check, show model, smt-search, and show smt-path, using Maude’s meta-interpreter. check . The check command determines the satisfiability of boolean formulas. For a given module M, a boolean formula f, and an (optional) SMT theory Th, it determines the satisfiability of f under the theory Th. check in M : f using Th . For example, consider a module EUF-EX. fmod EUF-EX is protecting INTEGER . sort A . op f : A-&gt; A [special (id-hook SMT_Symbol (EUF))] . op _xor_ : Integer Integer-&gt; A [prec 30 special (id-hook SMT_Symbol (EUF))] . op _===_ : A A-&gt; Boolean [special (id-hook SMT_Symbol (===))] . endfm . We can check the satisfiability using the command as follows: . MaudeSE&gt; check in EUF-EX : I:Integer &gt; 2 and I:Integer xor J:Integer &gt; 3 and f(X:A) === X:A . result: sat . show model . The show model command returns the satisfying assignment, if any, for the last check command. For example, we can get the assigment of the above check example as follows: . MaudeSE&gt; show model . assignment: I |--&gt; 3; J |--&gt; 2; X |--&gt; A!val!0; _xor_ |--&gt; [else-&gt; 4]; f |--&gt; [else-&gt; A!val!0] . smt-search . This command performs symbolic reachability analysis, along with folding. Given an initial term t, a goal pattern u, and a goal condition c, the following command searches for n solutions that are reachable within m rewrite steps from t, match the goal pattern u, and satisfy the goal condition c under the SMT theory Th: . {fold} smt-search [n,m] in M : t =&gt;* u such that c using Th . The arguments {fold}, Th, n, and m are optional. If {fold} is given, the command ignores constrained terms that are subsumed by other constrained terms. As an example, consider the following system module COFFEE-MACHINE that specifies the coffee machine parametric timed automaton (PTA). mod COFFEE-MACHINE is protecting REAL . sorts State Location . vars T X Y X' Y' P1 P2 P3 : Real . vars L L' : Location . var PHI : Boolean . ops idle addsugar preparingcoffee cdone :-&gt; Location . op &lt;_;_;_&gt; &lt;_;_;_&gt; : Location Real Real Real Real Real-&gt; State . op [_;_;_] &lt;_;_;_&gt; : Location Real Real Real Real Real-&gt; State . sort Tuple{Location,Real,Real,Boolean} . op {_,_,_,_} : Location Real Real Boolean-&gt; Tuple{Location,Real,Real,Boolean} [ctor] . crl [tick] : [ L ; X ; Y ] &lt; P1 ; P2 ; P3 &gt; =&gt; &lt; L ; X + T ; Y + T &gt; &lt; P1 ; P2 ; P3 &gt; if PHI := tickCond(L, T, X, Y, P2, P3) /\\ (T &gt;= 0/1 and PHI) = true [nonexec] . op tickCond : Location Real Real Real Real Real-&gt; Boolean . eq tickCond(idle, T, X, Y, P2, P3) = true . eq tickCond(addsugar, T, X, Y, P2, P3) = Y + T &lt;= P2 . eq tickCond(preparingcoffee, T, X, Y, P2, P3) = Y + T &lt;= P3 . eq tickCond(cdone, T, X, Y, P2, P3) = X + T &lt;= 10/1 . crl [toAddsugar] : &lt; L ; X ; Y &gt; &lt; P1 ; P2 ; P3 &gt; =&gt; [ L' ; X' ; Y' ] &lt; P1 ; P2 ; P3 &gt; if {L', X', Y', PHI} := nextAddSugar(L, X, Y, P1, P2) /\\ PHI = true . op nextAddSugar : Location Real Real Real Real-&gt; Tuple{Location,Real,Real,Boolean} . eq nextAddSugar(idle, X, Y, P1, P2) = {addsugar, 0/1, 0/1, 0/1 &lt;= P2} . eq nextAddSugar(addsugar, X, Y, P1, P2) = {addsugar, 0/1, Y, Y &lt;= P2 and X &gt;= P1} . eq nextAddSugar(cdone, X, Y, P1, P2) = {addsugar, 0/1, 0/1, 0/1 &lt;= P2} . crl [toOther] : &lt; L ; X ; Y &gt; &lt; P1 ; P2 ; P3 &gt; =&gt; [ L' ; X' ; Y' ] &lt; P1 ; P2 ; P3 &gt; if {L', X', Y', PHI} := nextOther(L, X, Y, P2, P3) /\\ PHI = true . op nextOther : Location Real Real Real Real-&gt; Tuple{Location,Real,Real,Boolean} . eq nextOther(addsugar, X, Y, P2, P3) = {preparingcoffee, X, Y, Y &lt;= P3 and Y === P2} . eq nextOther(preparingcoffee, X, Y, P2, P3) = {cdone, 0/1, Y, 0/1 &lt;= 10/1 and Y === P3} . eq nextOther(cdone, X, Y, P2, P3) = {idle, X, Y, X === 10/1} . endm . The following command finds the first solution of the PTA coffee machine that goes to cdone with all the clocks and parameters are greater than or equal to 0. MaudeSE&gt; {fold} smt-search [1, 10000] : &lt; idle ; X:Real ; Y:Real &gt; &lt; P1:Real ; P2:Real ; P3:Real &gt; =&gt;* &lt; cdone ; X’:Real ; Y’:Real &gt; &lt; P1:Real ; P2:Real ; P3:Real &gt; such that X:Real === Y:Real and X:Real &gt;= 0/1 and Y:Real &gt;= 0/1 and P1:Real &gt;= 0/1 and P2:Real &gt;= 0/1 and P3:Real &gt;= 0/1 . Solution 1 (state 12) Symbolic term: &lt; cdone ; %ubVar$8 ; %ubVar$9 &gt; &lt; PAR1 ; PAR2 ; PAR3 &gt; Constraint: T1 === T2 and T1 &gt;= 0/1 and T2 &gt;= 0/1 ... Substitution: %ubVar$1 &lt;-- 1/2 ; ... ; %ubVar$9 &lt;-- 1/2 ; ... Concrete term: &lt; cdone ; 0/1 ; 1/2 &gt; &lt; 1/2 ; 1/2 ; 1/2 &gt; . show smt-path . This command returns a symbolic/concrete path of the last smt-search result. It takes two arguments: a path type (either symbolic or concrete) and a state number. A symbolic path is given by a sequence of contracted terms and rewrite rules. The corresponding concrete path is an instance of the symbolic path with a satisfying assignment. For example, the following commands show the symbolic and concrete paths for Solution 3 of the above smt-search command. MaudeSE&gt; show smt-path symbolic 3 . { &lt; idle ; T1 ; T2 &gt; &lt; PAR1 ; PAR2 ; PAR3 &gt; || T1 === T2 ... } ====='[ toAddsugar ']=====&gt; { [addsugar ; 0/1 ; 0/1] &lt; PAR1 ; PAR2 ; PAR3 &gt; || T1 === T2 ... } ... MaudeSE&gt; show smt-path concrete 3 . &lt; idle ; 10/1 ; 10/1 &gt; &lt; 0/1 ; 0/1 ; 0/1 &gt; ===[ toAddsugar ]===&gt; [addsugar ; 0/1 ; 0/1] &lt; 0/1 ; 0/1 ; 0/1 &gt; ... ",
    "url": "/smt-interface#analysis-commands",
    "relUrl": "/smt-interface#analysis-commands"
  },"24": {
    "doc": "SMT Interface",
    "title": "Metalevel Functions",
    "content": "Maude-SE provides three meta-level functions: metaSmtCheck, metaSmtSearch2, and metaSmtSearch2Path. metaSmtCheck . Given a module M, a boolean formula f, and an SMT theory Th, the function metaSmtCheck(M',f',Th,b) returns the solution of the following command: . check in M : f using Th . The argument b is a Boolean flag for generating satisfying assignment. M' and f' are the metarepresentations of M and f, respectively, and Th is an optional argument. metaSmtSearch2 . Analogously, given an initial state t, a goal pattern u, and a goal condition c, the function metaSmtSearch2(M',t',u',c',*,m,k,Th,b) returns the (k + 1)-th solution of the smt-search command: . {fold} smt-search [n,m] in M : t =&gt;* u such that c using Th . The arugment b is a Boolean flag for folding, t', u', and c' denote the metarepresentations of t, u, and c, respectively, and k is less than n. metaSmtSearch2Path . If a solution exists for metaSmtSearch2, the function metaSmtSearch2Path(M',t',u',c',*,m,k,Th,b) returns a symbolic path and its concrete witness for the solution of the same command. ",
    "url": "/smt-interface#metalevel-functions",
    "relUrl": "/smt-interface#metalevel-functions"
  }
}
